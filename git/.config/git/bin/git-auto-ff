#! /usr/bin/env bash

set -euo pipefail

refs_tmp="$(mktemp /tmp/git-auto-ff.XXXX)"
detach_head_tmp="$(mktemp /tmp/git-auto-ff.XXXX)"
update_tmp="$(mktemp /tmp/git-auto-ff.XXXX)"

cleanup() {
	rm -f "$refs_tmp"
	rm -f "$update_tmp"
}
trap cleanup EXIT

git for-each-ref refs/heads --format '%(objecttype) %(refname) %(objectname) %(upstream) %(upstream:trackshort)' \
| tee "$refs_tmp"

if ! grep -Eq '^commit ([^ ]+) ([0-9a-f]+) (refs/remotes/origin/[^ ]+) <$' "$refs_tmp"; then
	echo 'No refs need fast-forwarding!' >&2
	echo --- >&2
	git for-each-ref refs/heads --format '%(objecttype) %(refname:short) %(upstream:short) %(upstream:track)' \
	| awk '$1 == "commit" && $3 != "" { for (i = 2; i <= NF; i++) printf("%s%s", $i, i == NF ? RS : OFS) }'
	echo --- >&2
	exit 0
fi

cut -d' ' -f 2,4 "$refs_tmp"
echo --- >&2

head="$(git symbolic-ref HEAD 2>/dev/null || true)"
head_oid="$(git for-each-ref --include-root-refs --format='%(objectname)' HEAD)"

message="git-auto-ff: $(date -Iseconds)"

echo --- >&2

if test -z "$head"; then
	echo 'HEAD does not need fast-forwarding, skipping detach!'
else
	tee "$detach_head_tmp" <<EOF
start
option no-deref
update HEAD $head_oid $head_oid
prepare
commit
EOF

	git update-ref -m "$message" --create-reflog --stdin <"$detach_head_tmp"
fi

echo --- >&2

awk -v head="$head" -v head_oid="$head_oid" '
BEGIN {
	print "start"
}

NF == 5 \
&& /^commit/ \
&& $3 ~ /[0-9a-f]+/ \
&& $4 ~ /refs\/remotes\/origin\/[^ ]+/ \
&& $5 == "<" {
	print "update", $2, $4, $3
}

END {
	print "prepare"
	print "commit"
}
' "$refs_tmp" \
| tee "$update_tmp"
echo --- >&2

git update-ref -m "$message" --create-reflog --stdin <"$update_tmp"
echo --- >&2
